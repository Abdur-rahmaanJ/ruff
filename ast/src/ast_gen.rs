// File automatically generated by ast/asdl_rs.py.

#![allow(clippy::derive_partial_eq_without_eq)]

pub use crate::constant::*;
pub use ruff_text_size::{TextRange, TextSize};

type Ident = String;

#[derive(Clone, Debug, PartialEq)]
pub struct Located<T, U = ()> {
    pub range: TextRange,
    pub custom: U,
    pub node: T,
}

impl<T> Located<T> {
    pub fn new(start: TextSize, end: TextSize, node: T) -> Self {
        Self {
            range: TextRange::new(start, end),
            custom: (),
            node,
        }
    }

    /// Creates a new node that spans the position specified by `range`.
    pub fn with_range(node: T, range: TextRange) -> Self {
        Self {
            range,
            custom: (),
            node,
        }
    }

    /// Returns the absolute start position of the node from the beginning of the document.
    #[inline]
    pub const fn start(&self) -> TextSize {
        self.range.start()
    }

    /// Returns the node
    #[inline]
    pub fn node(&self) -> &T {
        &self.node
    }

    /// Consumes self and returns the node.
    #[inline]
    pub fn into_node(self) -> T {
        self.node
    }

    /// Returns the `range` of the node. The range offsets are absolute to the start of the document.
    #[inline]
    pub const fn range(&self) -> TextRange {
        self.range
    }

    /// Returns the absolute position at which the node ends in the source document.
    #[inline]
    pub const fn end(&self) -> TextSize {
        self.range.end()
    }
}

impl<T, U> std::ops::Deref for Located<T, U> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.node
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ModModule<U = ()> {
    pub body: Vec<Stmt<U>>,
    pub type_ignores: Vec<TypeIgnore>,
}

impl<U> From<ModModule<U>> for Mod<U> {
    fn from(payload: ModModule<U>) -> Self {
        Mod::Module(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ModInteractive<U = ()> {
    pub body: Vec<Stmt<U>>,
}

impl<U> From<ModInteractive<U>> for Mod<U> {
    fn from(payload: ModInteractive<U>) -> Self {
        Mod::Interactive(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ModExpression<U = ()> {
    pub body: Box<Expr<U>>,
}

impl<U> From<ModExpression<U>> for Mod<U> {
    fn from(payload: ModExpression<U>) -> Self {
        Mod::Expression(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ModFunctionType<U = ()> {
    pub argtypes: Vec<Expr<U>>,
    pub returns: Box<Expr<U>>,
}

impl<U> From<ModFunctionType<U>> for Mod<U> {
    fn from(payload: ModFunctionType<U>) -> Self {
        Mod::FunctionType(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub enum Mod<U = ()> {
    Module(ModModule<U>),
    Interactive(ModInteractive<U>),
    Expression(ModExpression<U>),
    FunctionType(ModFunctionType<U>),
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtFunctionDef<U = ()> {
    pub name: Ident,
    pub args: Box<Arguments<U>>,
    pub body: Vec<Stmt<U>>,
    pub decorator_list: Vec<Expr<U>>,
    pub returns: Option<Box<Expr<U>>>,
    pub type_comment: Option<String>,
}

impl<U> From<StmtFunctionDef<U>> for StmtKind<U> {
    fn from(payload: StmtFunctionDef<U>) -> Self {
        StmtKind::FunctionDef(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtAsyncFunctionDef<U = ()> {
    pub name: Ident,
    pub args: Box<Arguments<U>>,
    pub body: Vec<Stmt<U>>,
    pub decorator_list: Vec<Expr<U>>,
    pub returns: Option<Box<Expr<U>>>,
    pub type_comment: Option<String>,
}

impl<U> From<StmtAsyncFunctionDef<U>> for StmtKind<U> {
    fn from(payload: StmtAsyncFunctionDef<U>) -> Self {
        StmtKind::AsyncFunctionDef(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtClassDef<U = ()> {
    pub name: Ident,
    pub bases: Vec<Expr<U>>,
    pub keywords: Vec<Keyword<U>>,
    pub body: Vec<Stmt<U>>,
    pub decorator_list: Vec<Expr<U>>,
}

impl<U> From<StmtClassDef<U>> for StmtKind<U> {
    fn from(payload: StmtClassDef<U>) -> Self {
        StmtKind::ClassDef(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtReturn<U = ()> {
    pub value: Option<Box<Expr<U>>>,
}

impl<U> From<StmtReturn<U>> for StmtKind<U> {
    fn from(payload: StmtReturn<U>) -> Self {
        StmtKind::Return(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtDelete<U = ()> {
    pub targets: Vec<Expr<U>>,
}

impl<U> From<StmtDelete<U>> for StmtKind<U> {
    fn from(payload: StmtDelete<U>) -> Self {
        StmtKind::Delete(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtAssign<U = ()> {
    pub targets: Vec<Expr<U>>,
    pub value: Box<Expr<U>>,
    pub type_comment: Option<String>,
}

impl<U> From<StmtAssign<U>> for StmtKind<U> {
    fn from(payload: StmtAssign<U>) -> Self {
        StmtKind::Assign(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtAugAssign<U = ()> {
    pub target: Box<Expr<U>>,
    pub op: Operator,
    pub value: Box<Expr<U>>,
}

impl<U> From<StmtAugAssign<U>> for StmtKind<U> {
    fn from(payload: StmtAugAssign<U>) -> Self {
        StmtKind::AugAssign(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtAnnAssign<U = ()> {
    pub target: Box<Expr<U>>,
    pub annotation: Box<Expr<U>>,
    pub value: Option<Box<Expr<U>>>,
    pub simple: usize,
}

impl<U> From<StmtAnnAssign<U>> for StmtKind<U> {
    fn from(payload: StmtAnnAssign<U>) -> Self {
        StmtKind::AnnAssign(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtFor<U = ()> {
    pub target: Box<Expr<U>>,
    pub iter: Box<Expr<U>>,
    pub body: Vec<Stmt<U>>,
    pub orelse: Vec<Stmt<U>>,
    pub type_comment: Option<String>,
}

impl<U> From<StmtFor<U>> for StmtKind<U> {
    fn from(payload: StmtFor<U>) -> Self {
        StmtKind::For(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtAsyncFor<U = ()> {
    pub target: Box<Expr<U>>,
    pub iter: Box<Expr<U>>,
    pub body: Vec<Stmt<U>>,
    pub orelse: Vec<Stmt<U>>,
    pub type_comment: Option<String>,
}

impl<U> From<StmtAsyncFor<U>> for StmtKind<U> {
    fn from(payload: StmtAsyncFor<U>) -> Self {
        StmtKind::AsyncFor(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtWhile<U = ()> {
    pub test: Box<Expr<U>>,
    pub body: Vec<Stmt<U>>,
    pub orelse: Vec<Stmt<U>>,
}

impl<U> From<StmtWhile<U>> for StmtKind<U> {
    fn from(payload: StmtWhile<U>) -> Self {
        StmtKind::While(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtIf<U = ()> {
    pub test: Box<Expr<U>>,
    pub body: Vec<Stmt<U>>,
    pub orelse: Vec<Stmt<U>>,
}

impl<U> From<StmtIf<U>> for StmtKind<U> {
    fn from(payload: StmtIf<U>) -> Self {
        StmtKind::If(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtWith<U = ()> {
    pub items: Vec<Withitem<U>>,
    pub body: Vec<Stmt<U>>,
    pub type_comment: Option<String>,
}

impl<U> From<StmtWith<U>> for StmtKind<U> {
    fn from(payload: StmtWith<U>) -> Self {
        StmtKind::With(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtAsyncWith<U = ()> {
    pub items: Vec<Withitem<U>>,
    pub body: Vec<Stmt<U>>,
    pub type_comment: Option<String>,
}

impl<U> From<StmtAsyncWith<U>> for StmtKind<U> {
    fn from(payload: StmtAsyncWith<U>) -> Self {
        StmtKind::AsyncWith(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtMatch<U = ()> {
    pub subject: Box<Expr<U>>,
    pub cases: Vec<MatchCase<U>>,
}

impl<U> From<StmtMatch<U>> for StmtKind<U> {
    fn from(payload: StmtMatch<U>) -> Self {
        StmtKind::Match(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtRaise<U = ()> {
    pub exc: Option<Box<Expr<U>>>,
    pub cause: Option<Box<Expr<U>>>,
}

impl<U> From<StmtRaise<U>> for StmtKind<U> {
    fn from(payload: StmtRaise<U>) -> Self {
        StmtKind::Raise(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtTry<U = ()> {
    pub body: Vec<Stmt<U>>,
    pub handlers: Vec<Excepthandler<U>>,
    pub orelse: Vec<Stmt<U>>,
    pub finalbody: Vec<Stmt<U>>,
}

impl<U> From<StmtTry<U>> for StmtKind<U> {
    fn from(payload: StmtTry<U>) -> Self {
        StmtKind::Try(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtTryStar<U = ()> {
    pub body: Vec<Stmt<U>>,
    pub handlers: Vec<Excepthandler<U>>,
    pub orelse: Vec<Stmt<U>>,
    pub finalbody: Vec<Stmt<U>>,
}

impl<U> From<StmtTryStar<U>> for StmtKind<U> {
    fn from(payload: StmtTryStar<U>) -> Self {
        StmtKind::TryStar(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtAssert<U = ()> {
    pub test: Box<Expr<U>>,
    pub msg: Option<Box<Expr<U>>>,
}

impl<U> From<StmtAssert<U>> for StmtKind<U> {
    fn from(payload: StmtAssert<U>) -> Self {
        StmtKind::Assert(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtImport<U = ()> {
    pub names: Vec<Alias<U>>,
}

impl<U> From<StmtImport<U>> for StmtKind<U> {
    fn from(payload: StmtImport<U>) -> Self {
        StmtKind::Import(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtImportFrom<U = ()> {
    pub module: Option<Ident>,
    pub names: Vec<Alias<U>>,
    pub level: Option<usize>,
}

impl<U> From<StmtImportFrom<U>> for StmtKind<U> {
    fn from(payload: StmtImportFrom<U>) -> Self {
        StmtKind::ImportFrom(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtGlobal {
    pub names: Vec<Ident>,
}

impl From<StmtGlobal> for StmtKind {
    fn from(payload: StmtGlobal) -> Self {
        StmtKind::Global(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtNonlocal {
    pub names: Vec<Ident>,
}

impl From<StmtNonlocal> for StmtKind {
    fn from(payload: StmtNonlocal) -> Self {
        StmtKind::Nonlocal(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct StmtExpr<U = ()> {
    pub value: Box<Expr<U>>,
}

impl<U> From<StmtExpr<U>> for StmtKind<U> {
    fn from(payload: StmtExpr<U>) -> Self {
        StmtKind::Expr(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub enum StmtKind<U = ()> {
    FunctionDef(StmtFunctionDef<U>),
    AsyncFunctionDef(StmtAsyncFunctionDef<U>),
    ClassDef(StmtClassDef<U>),
    Return(StmtReturn<U>),
    Delete(StmtDelete<U>),
    Assign(StmtAssign<U>),
    AugAssign(StmtAugAssign<U>),
    AnnAssign(StmtAnnAssign<U>),
    For(StmtFor<U>),
    AsyncFor(StmtAsyncFor<U>),
    While(StmtWhile<U>),
    If(StmtIf<U>),
    With(StmtWith<U>),
    AsyncWith(StmtAsyncWith<U>),
    Match(StmtMatch<U>),
    Raise(StmtRaise<U>),
    Try(StmtTry<U>),
    TryStar(StmtTryStar<U>),
    Assert(StmtAssert<U>),
    Import(StmtImport<U>),
    ImportFrom(StmtImportFrom<U>),
    Global(StmtGlobal),
    Nonlocal(StmtNonlocal),
    Expr(StmtExpr<U>),
    Pass,
    Break,
    Continue,
}
pub type Stmt<U = ()> = Located<StmtKind<U>, U>;

#[derive(Clone, Debug, PartialEq)]
pub struct ExprBoolOp<U = ()> {
    pub op: Boolop,
    pub values: Vec<Expr<U>>,
}

impl<U> From<ExprBoolOp<U>> for ExprKind<U> {
    fn from(payload: ExprBoolOp<U>) -> Self {
        ExprKind::BoolOp(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprNamedExpr<U = ()> {
    pub target: Box<Expr<U>>,
    pub value: Box<Expr<U>>,
}

impl<U> From<ExprNamedExpr<U>> for ExprKind<U> {
    fn from(payload: ExprNamedExpr<U>) -> Self {
        ExprKind::NamedExpr(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprBinOp<U = ()> {
    pub left: Box<Expr<U>>,
    pub op: Operator,
    pub right: Box<Expr<U>>,
}

impl<U> From<ExprBinOp<U>> for ExprKind<U> {
    fn from(payload: ExprBinOp<U>) -> Self {
        ExprKind::BinOp(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprUnaryOp<U = ()> {
    pub op: Unaryop,
    pub operand: Box<Expr<U>>,
}

impl<U> From<ExprUnaryOp<U>> for ExprKind<U> {
    fn from(payload: ExprUnaryOp<U>) -> Self {
        ExprKind::UnaryOp(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprLambda<U = ()> {
    pub args: Box<Arguments<U>>,
    pub body: Box<Expr<U>>,
}

impl<U> From<ExprLambda<U>> for ExprKind<U> {
    fn from(payload: ExprLambda<U>) -> Self {
        ExprKind::Lambda(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprIfExp<U = ()> {
    pub test: Box<Expr<U>>,
    pub body: Box<Expr<U>>,
    pub orelse: Box<Expr<U>>,
}

impl<U> From<ExprIfExp<U>> for ExprKind<U> {
    fn from(payload: ExprIfExp<U>) -> Self {
        ExprKind::IfExp(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprDict<U = ()> {
    pub keys: Vec<Option<Expr<U>>>,
    pub values: Vec<Expr<U>>,
}

impl<U> From<ExprDict<U>> for ExprKind<U> {
    fn from(payload: ExprDict<U>) -> Self {
        ExprKind::Dict(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprSet<U = ()> {
    pub elts: Vec<Expr<U>>,
}

impl<U> From<ExprSet<U>> for ExprKind<U> {
    fn from(payload: ExprSet<U>) -> Self {
        ExprKind::Set(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprListComp<U = ()> {
    pub elt: Box<Expr<U>>,
    pub generators: Vec<Comprehension<U>>,
}

impl<U> From<ExprListComp<U>> for ExprKind<U> {
    fn from(payload: ExprListComp<U>) -> Self {
        ExprKind::ListComp(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprSetComp<U = ()> {
    pub elt: Box<Expr<U>>,
    pub generators: Vec<Comprehension<U>>,
}

impl<U> From<ExprSetComp<U>> for ExprKind<U> {
    fn from(payload: ExprSetComp<U>) -> Self {
        ExprKind::SetComp(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprDictComp<U = ()> {
    pub key: Box<Expr<U>>,
    pub value: Box<Expr<U>>,
    pub generators: Vec<Comprehension<U>>,
}

impl<U> From<ExprDictComp<U>> for ExprKind<U> {
    fn from(payload: ExprDictComp<U>) -> Self {
        ExprKind::DictComp(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprGeneratorExp<U = ()> {
    pub elt: Box<Expr<U>>,
    pub generators: Vec<Comprehension<U>>,
}

impl<U> From<ExprGeneratorExp<U>> for ExprKind<U> {
    fn from(payload: ExprGeneratorExp<U>) -> Self {
        ExprKind::GeneratorExp(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprAwait<U = ()> {
    pub value: Box<Expr<U>>,
}

impl<U> From<ExprAwait<U>> for ExprKind<U> {
    fn from(payload: ExprAwait<U>) -> Self {
        ExprKind::Await(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprYield<U = ()> {
    pub value: Option<Box<Expr<U>>>,
}

impl<U> From<ExprYield<U>> for ExprKind<U> {
    fn from(payload: ExprYield<U>) -> Self {
        ExprKind::Yield(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprYieldFrom<U = ()> {
    pub value: Box<Expr<U>>,
}

impl<U> From<ExprYieldFrom<U>> for ExprKind<U> {
    fn from(payload: ExprYieldFrom<U>) -> Self {
        ExprKind::YieldFrom(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprCompare<U = ()> {
    pub left: Box<Expr<U>>,
    pub ops: Vec<Cmpop>,
    pub comparators: Vec<Expr<U>>,
}

impl<U> From<ExprCompare<U>> for ExprKind<U> {
    fn from(payload: ExprCompare<U>) -> Self {
        ExprKind::Compare(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprCall<U = ()> {
    pub func: Box<Expr<U>>,
    pub args: Vec<Expr<U>>,
    pub keywords: Vec<Keyword<U>>,
}

impl<U> From<ExprCall<U>> for ExprKind<U> {
    fn from(payload: ExprCall<U>) -> Self {
        ExprKind::Call(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprFormattedValue<U = ()> {
    pub value: Box<Expr<U>>,
    pub conversion: usize,
    pub format_spec: Option<Box<Expr<U>>>,
}

impl<U> From<ExprFormattedValue<U>> for ExprKind<U> {
    fn from(payload: ExprFormattedValue<U>) -> Self {
        ExprKind::FormattedValue(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprJoinedStr<U = ()> {
    pub values: Vec<Expr<U>>,
}

impl<U> From<ExprJoinedStr<U>> for ExprKind<U> {
    fn from(payload: ExprJoinedStr<U>) -> Self {
        ExprKind::JoinedStr(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprConstant {
    pub value: Constant,
    pub kind: Option<String>,
}

impl From<ExprConstant> for ExprKind {
    fn from(payload: ExprConstant) -> Self {
        ExprKind::Constant(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprAttribute<U = ()> {
    pub value: Box<Expr<U>>,
    pub attr: Ident,
    pub ctx: ExprContext,
}

impl<U> From<ExprAttribute<U>> for ExprKind<U> {
    fn from(payload: ExprAttribute<U>) -> Self {
        ExprKind::Attribute(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprSubscript<U = ()> {
    pub value: Box<Expr<U>>,
    pub slice: Box<Expr<U>>,
    pub ctx: ExprContext,
}

impl<U> From<ExprSubscript<U>> for ExprKind<U> {
    fn from(payload: ExprSubscript<U>) -> Self {
        ExprKind::Subscript(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprStarred<U = ()> {
    pub value: Box<Expr<U>>,
    pub ctx: ExprContext,
}

impl<U> From<ExprStarred<U>> for ExprKind<U> {
    fn from(payload: ExprStarred<U>) -> Self {
        ExprKind::Starred(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprName {
    pub id: Ident,
    pub ctx: ExprContext,
}

impl From<ExprName> for ExprKind {
    fn from(payload: ExprName) -> Self {
        ExprKind::Name(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprList<U = ()> {
    pub elts: Vec<Expr<U>>,
    pub ctx: ExprContext,
}

impl<U> From<ExprList<U>> for ExprKind<U> {
    fn from(payload: ExprList<U>) -> Self {
        ExprKind::List(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprTuple<U = ()> {
    pub elts: Vec<Expr<U>>,
    pub ctx: ExprContext,
}

impl<U> From<ExprTuple<U>> for ExprKind<U> {
    fn from(payload: ExprTuple<U>) -> Self {
        ExprKind::Tuple(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExprSlice<U = ()> {
    pub lower: Option<Box<Expr<U>>>,
    pub upper: Option<Box<Expr<U>>>,
    pub step: Option<Box<Expr<U>>>,
}

impl<U> From<ExprSlice<U>> for ExprKind<U> {
    fn from(payload: ExprSlice<U>) -> Self {
        ExprKind::Slice(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub enum ExprKind<U = ()> {
    BoolOp(ExprBoolOp<U>),
    NamedExpr(ExprNamedExpr<U>),
    BinOp(ExprBinOp<U>),
    UnaryOp(ExprUnaryOp<U>),
    Lambda(ExprLambda<U>),
    IfExp(ExprIfExp<U>),
    Dict(ExprDict<U>),
    Set(ExprSet<U>),
    ListComp(ExprListComp<U>),
    SetComp(ExprSetComp<U>),
    DictComp(ExprDictComp<U>),
    GeneratorExp(ExprGeneratorExp<U>),
    Await(ExprAwait<U>),
    Yield(ExprYield<U>),
    YieldFrom(ExprYieldFrom<U>),
    Compare(ExprCompare<U>),
    Call(ExprCall<U>),
    FormattedValue(ExprFormattedValue<U>),
    JoinedStr(ExprJoinedStr<U>),
    Constant(ExprConstant),
    Attribute(ExprAttribute<U>),
    Subscript(ExprSubscript<U>),
    Starred(ExprStarred<U>),
    Name(ExprName),
    List(ExprList<U>),
    Tuple(ExprTuple<U>),
    Slice(ExprSlice<U>),
}
pub type Expr<U = ()> = Located<ExprKind<U>, U>;

#[derive(Clone, Debug, PartialEq)]
pub enum ExprContext {
    Load,
    Store,
    Del,
}

#[derive(Clone, Debug, PartialEq)]
pub enum Boolop {
    And,
    Or,
}

#[derive(Clone, Debug, PartialEq)]
pub enum Operator {
    Add,
    Sub,
    Mult,
    MatMult,
    Div,
    Mod,
    Pow,
    LShift,
    RShift,
    BitOr,
    BitXor,
    BitAnd,
    FloorDiv,
}

#[derive(Clone, Debug, PartialEq)]
pub enum Unaryop {
    Invert,
    Not,
    UAdd,
    USub,
}

#[derive(Clone, Debug, PartialEq)]
pub enum Cmpop {
    Eq,
    NotEq,
    Lt,
    LtE,
    Gt,
    GtE,
    Is,
    IsNot,
    In,
    NotIn,
}

#[derive(Clone, Debug, PartialEq)]
pub struct Comprehension<U = ()> {
    pub target: Expr<U>,
    pub iter: Expr<U>,
    pub ifs: Vec<Expr<U>>,
    pub is_async: usize,
}

#[derive(Clone, Debug, PartialEq)]
pub struct ExcepthandlerExceptHandler<U = ()> {
    pub type_: Option<Box<Expr<U>>>,
    pub name: Option<Ident>,
    pub body: Vec<Stmt<U>>,
}

impl<U> From<ExcepthandlerExceptHandler<U>> for ExcepthandlerKind<U> {
    fn from(payload: ExcepthandlerExceptHandler<U>) -> Self {
        ExcepthandlerKind::ExceptHandler(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub enum ExcepthandlerKind<U = ()> {
    ExceptHandler(ExcepthandlerExceptHandler<U>),
}
pub type Excepthandler<U = ()> = Located<ExcepthandlerKind<U>, U>;

#[derive(Clone, Debug, PartialEq)]
pub struct Arguments<U = ()> {
    pub posonlyargs: Vec<Arg<U>>,
    pub args: Vec<Arg<U>>,
    pub vararg: Option<Box<Arg<U>>>,
    pub kwonlyargs: Vec<Arg<U>>,
    pub kw_defaults: Vec<Expr<U>>,
    pub kwarg: Option<Box<Arg<U>>>,
    pub defaults: Vec<Expr<U>>,
}

#[derive(Clone, Debug, PartialEq)]
pub struct ArgData<U = ()> {
    pub arg: Ident,
    pub annotation: Option<Box<Expr<U>>>,
    pub type_comment: Option<String>,
}
pub type Arg<U = ()> = Located<ArgData<U>, U>;

#[derive(Clone, Debug, PartialEq)]
pub struct KeywordData<U = ()> {
    pub arg: Option<Ident>,
    pub value: Expr<U>,
}
pub type Keyword<U = ()> = Located<KeywordData<U>, U>;

#[derive(Clone, Debug, PartialEq)]
pub struct AliasData {
    pub name: Ident,
    pub asname: Option<Ident>,
}
pub type Alias<U = ()> = Located<AliasData, U>;

#[derive(Clone, Debug, PartialEq)]
pub struct Withitem<U = ()> {
    pub context_expr: Expr<U>,
    pub optional_vars: Option<Box<Expr<U>>>,
}

#[derive(Clone, Debug, PartialEq)]
pub struct MatchCase<U = ()> {
    pub pattern: Pattern<U>,
    pub guard: Option<Box<Expr<U>>>,
    pub body: Vec<Stmt<U>>,
}

#[derive(Clone, Debug, PartialEq)]
pub struct PatternMatchValue<U = ()> {
    pub value: Box<Expr<U>>,
}

impl<U> From<PatternMatchValue<U>> for PatternKind<U> {
    fn from(payload: PatternMatchValue<U>) -> Self {
        PatternKind::MatchValue(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct PatternMatchSingleton {
    pub value: Constant,
}

impl From<PatternMatchSingleton> for PatternKind {
    fn from(payload: PatternMatchSingleton) -> Self {
        PatternKind::MatchSingleton(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct PatternMatchSequence<U = ()> {
    pub patterns: Vec<Pattern<U>>,
}

impl<U> From<PatternMatchSequence<U>> for PatternKind<U> {
    fn from(payload: PatternMatchSequence<U>) -> Self {
        PatternKind::MatchSequence(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct PatternMatchMapping<U = ()> {
    pub keys: Vec<Expr<U>>,
    pub patterns: Vec<Pattern<U>>,
    pub rest: Option<Ident>,
}

impl<U> From<PatternMatchMapping<U>> for PatternKind<U> {
    fn from(payload: PatternMatchMapping<U>) -> Self {
        PatternKind::MatchMapping(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct PatternMatchClass<U = ()> {
    pub cls: Box<Expr<U>>,
    pub patterns: Vec<Pattern<U>>,
    pub kwd_attrs: Vec<Ident>,
    pub kwd_patterns: Vec<Pattern<U>>,
}

impl<U> From<PatternMatchClass<U>> for PatternKind<U> {
    fn from(payload: PatternMatchClass<U>) -> Self {
        PatternKind::MatchClass(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct PatternMatchStar {
    pub name: Option<Ident>,
}

impl From<PatternMatchStar> for PatternKind {
    fn from(payload: PatternMatchStar) -> Self {
        PatternKind::MatchStar(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct PatternMatchAs<U = ()> {
    pub pattern: Option<Box<Pattern<U>>>,
    pub name: Option<Ident>,
}

impl<U> From<PatternMatchAs<U>> for PatternKind<U> {
    fn from(payload: PatternMatchAs<U>) -> Self {
        PatternKind::MatchAs(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub struct PatternMatchOr<U = ()> {
    pub patterns: Vec<Pattern<U>>,
}

impl<U> From<PatternMatchOr<U>> for PatternKind<U> {
    fn from(payload: PatternMatchOr<U>) -> Self {
        PatternKind::MatchOr(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub enum PatternKind<U = ()> {
    MatchValue(PatternMatchValue<U>),
    MatchSingleton(PatternMatchSingleton),
    MatchSequence(PatternMatchSequence<U>),
    MatchMapping(PatternMatchMapping<U>),
    MatchClass(PatternMatchClass<U>),
    MatchStar(PatternMatchStar),
    MatchAs(PatternMatchAs<U>),
    MatchOr(PatternMatchOr<U>),
}
pub type Pattern<U = ()> = Located<PatternKind<U>, U>;

#[derive(Clone, Debug, PartialEq)]
pub struct TypeIgnoreTypeIgnore {
    pub lineno: usize,
    pub tag: String,
}

impl From<TypeIgnoreTypeIgnore> for TypeIgnore {
    fn from(payload: TypeIgnoreTypeIgnore) -> Self {
        TypeIgnore::TypeIgnore(payload)
    }
}

#[derive(Clone, Debug, PartialEq)]
pub enum TypeIgnore {
    TypeIgnore(TypeIgnoreTypeIgnore),
}

#[cfg(feature = "fold")]
pub mod fold {
    use super::*;
    use crate::fold_helpers::Foldable;
    pub trait Fold<U> {
        type TargetU;
        type Error;
        fn map_user(&mut self, user: U) -> Result<Self::TargetU, Self::Error>;
        fn fold_mod(&mut self, node: Mod<U>) -> Result<Mod<Self::TargetU>, Self::Error> {
            fold_mod(self, node)
        }
        fn fold_stmt(&mut self, node: Stmt<U>) -> Result<Stmt<Self::TargetU>, Self::Error> {
            fold_stmt(self, node)
        }
        fn fold_expr(&mut self, node: Expr<U>) -> Result<Expr<Self::TargetU>, Self::Error> {
            fold_expr(self, node)
        }
        fn fold_expr_context(&mut self, node: ExprContext) -> Result<ExprContext, Self::Error> {
            fold_expr_context(self, node)
        }
        fn fold_boolop(&mut self, node: Boolop) -> Result<Boolop, Self::Error> {
            fold_boolop(self, node)
        }
        fn fold_operator(&mut self, node: Operator) -> Result<Operator, Self::Error> {
            fold_operator(self, node)
        }
        fn fold_unaryop(&mut self, node: Unaryop) -> Result<Unaryop, Self::Error> {
            fold_unaryop(self, node)
        }
        fn fold_cmpop(&mut self, node: Cmpop) -> Result<Cmpop, Self::Error> {
            fold_cmpop(self, node)
        }
        fn fold_comprehension(
            &mut self,
            node: Comprehension<U>,
        ) -> Result<Comprehension<Self::TargetU>, Self::Error> {
            fold_comprehension(self, node)
        }
        fn fold_excepthandler(
            &mut self,
            node: Excepthandler<U>,
        ) -> Result<Excepthandler<Self::TargetU>, Self::Error> {
            fold_excepthandler(self, node)
        }
        fn fold_arguments(
            &mut self,
            node: Arguments<U>,
        ) -> Result<Arguments<Self::TargetU>, Self::Error> {
            fold_arguments(self, node)
        }
        fn fold_arg(&mut self, node: Arg<U>) -> Result<Arg<Self::TargetU>, Self::Error> {
            fold_arg(self, node)
        }
        fn fold_keyword(
            &mut self,
            node: Keyword<U>,
        ) -> Result<Keyword<Self::TargetU>, Self::Error> {
            fold_keyword(self, node)
        }
        fn fold_alias(&mut self, node: Alias<U>) -> Result<Alias<Self::TargetU>, Self::Error> {
            fold_alias(self, node)
        }
        fn fold_withitem(
            &mut self,
            node: Withitem<U>,
        ) -> Result<Withitem<Self::TargetU>, Self::Error> {
            fold_withitem(self, node)
        }
        fn fold_match_case(
            &mut self,
            node: MatchCase<U>,
        ) -> Result<MatchCase<Self::TargetU>, Self::Error> {
            fold_match_case(self, node)
        }
        fn fold_pattern(
            &mut self,
            node: Pattern<U>,
        ) -> Result<Pattern<Self::TargetU>, Self::Error> {
            fold_pattern(self, node)
        }
        fn fold_type_ignore(&mut self, node: TypeIgnore) -> Result<TypeIgnore, Self::Error> {
            fold_type_ignore(self, node)
        }
    }
    fn fold_located<U, F: Fold<U> + ?Sized, T, MT>(
        folder: &mut F,
        node: Located<T, U>,
        f: impl FnOnce(&mut F, T) -> Result<MT, F::Error>,
    ) -> Result<Located<MT, F::TargetU>, F::Error> {
        Ok(Located {
            custom: folder.map_user(node.custom)?,
            range: node.range,
            node: f(folder, node.node)?,
        })
    }
    impl<T, U> Foldable<T, U> for Mod<T> {
        type Mapped = Mod<U>;
        fn fold<F: Fold<T, TargetU = U> + ?Sized>(
            self,
            folder: &mut F,
        ) -> Result<Self::Mapped, F::Error> {
            folder.fold_mod(self)
        }
    }
    pub fn fold_mod<U, F: Fold<U> + ?Sized>(
        #[allow(unused)] folder: &mut F,
        node: Mod<U>,
    ) -> Result<Mod<F::TargetU>, F::Error> {
        match node {
            Mod::Module(ModModule { body, type_ignores }) => Ok(Mod::Module(ModModule {
                body: Foldable::fold(body, folder)?,
                type_ignores: Foldable::fold(type_ignores, folder)?,
            })),
            Mod::Interactive(ModInteractive { body }) => Ok(Mod::Interactive(ModInteractive {
                body: Foldable::fold(body, folder)?,
            })),
            Mod::Expression(ModExpression { body }) => Ok(Mod::Expression(ModExpression {
                body: Foldable::fold(body, folder)?,
            })),
            Mod::FunctionType(ModFunctionType { argtypes, returns }) => {
                Ok(Mod::FunctionType(ModFunctionType {
                    argtypes: Foldable::fold(argtypes, folder)?,
                    returns: Foldable::fold(returns, folder)?,
                }))
            }
        }
    }
    impl<T, U> Foldable<T, U> for Stmt<T> {
        type Mapped = Stmt<U>;
        fn fold<F: Fold<T, TargetU = U> + ?Sized>(
            self,
            folder: &mut F,
        ) -> Result<Self::Mapped, F::Error> {
            folder.fold_stmt(self)
        }
    }
    pub fn fold_stmt<U, F: Fold<U> + ?Sized>(
        #[allow(unused)] folder: &mut F,
        node: Stmt<U>,
    ) -> Result<Stmt<F::TargetU>, F::Error> {
        fold_located(folder, node, |folder, node| match node {
            StmtKind::FunctionDef(StmtFunctionDef {
                name,
                args,
                body,
                decorator_list,
                returns,
                type_comment,
            }) => Ok(StmtKind::FunctionDef(StmtFunctionDef {
                name: Foldable::fold(name, folder)?,
                args: Foldable::fold(args, folder)?,
                body: Foldable::fold(body, folder)?,
                decorator_list: Foldable::fold(decorator_list, folder)?,
                returns: Foldable::fold(returns, folder)?,
                type_comment: Foldable::fold(type_comment, folder)?,
            })),
            StmtKind::AsyncFunctionDef(StmtAsyncFunctionDef {
                name,
                args,
                body,
                decorator_list,
                returns,
                type_comment,
            }) => Ok(StmtKind::AsyncFunctionDef(StmtAsyncFunctionDef {
                name: Foldable::fold(name, folder)?,
                args: Foldable::fold(args, folder)?,
                body: Foldable::fold(body, folder)?,
                decorator_list: Foldable::fold(decorator_list, folder)?,
                returns: Foldable::fold(returns, folder)?,
                type_comment: Foldable::fold(type_comment, folder)?,
            })),
            StmtKind::ClassDef(StmtClassDef {
                name,
                bases,
                keywords,
                body,
                decorator_list,
            }) => Ok(StmtKind::ClassDef(StmtClassDef {
                name: Foldable::fold(name, folder)?,
                bases: Foldable::fold(bases, folder)?,
                keywords: Foldable::fold(keywords, folder)?,
                body: Foldable::fold(body, folder)?,
                decorator_list: Foldable::fold(decorator_list, folder)?,
            })),
            StmtKind::Return(StmtReturn { value }) => Ok(StmtKind::Return(StmtReturn {
                value: Foldable::fold(value, folder)?,
            })),
            StmtKind::Delete(StmtDelete { targets }) => Ok(StmtKind::Delete(StmtDelete {
                targets: Foldable::fold(targets, folder)?,
            })),
            StmtKind::Assign(StmtAssign {
                targets,
                value,
                type_comment,
            }) => Ok(StmtKind::Assign(StmtAssign {
                targets: Foldable::fold(targets, folder)?,
                value: Foldable::fold(value, folder)?,
                type_comment: Foldable::fold(type_comment, folder)?,
            })),
            StmtKind::AugAssign(StmtAugAssign { target, op, value }) => {
                Ok(StmtKind::AugAssign(StmtAugAssign {
                    target: Foldable::fold(target, folder)?,
                    op: Foldable::fold(op, folder)?,
                    value: Foldable::fold(value, folder)?,
                }))
            }
            StmtKind::AnnAssign(StmtAnnAssign {
                target,
                annotation,
                value,
                simple,
            }) => Ok(StmtKind::AnnAssign(StmtAnnAssign {
                target: Foldable::fold(target, folder)?,
                annotation: Foldable::fold(annotation, folder)?,
                value: Foldable::fold(value, folder)?,
                simple: Foldable::fold(simple, folder)?,
            })),
            StmtKind::For(StmtFor {
                target,
                iter,
                body,
                orelse,
                type_comment,
            }) => Ok(StmtKind::For(StmtFor {
                target: Foldable::fold(target, folder)?,
                iter: Foldable::fold(iter, folder)?,
                body: Foldable::fold(body, folder)?,
                orelse: Foldable::fold(orelse, folder)?,
                type_comment: Foldable::fold(type_comment, folder)?,
            })),
            StmtKind::AsyncFor(StmtAsyncFor {
                target,
                iter,
                body,
                orelse,
                type_comment,
            }) => Ok(StmtKind::AsyncFor(StmtAsyncFor {
                target: Foldable::fold(target, folder)?,
                iter: Foldable::fold(iter, folder)?,
                body: Foldable::fold(body, folder)?,
                orelse: Foldable::fold(orelse, folder)?,
                type_comment: Foldable::fold(type_comment, folder)?,
            })),
            StmtKind::While(StmtWhile { test, body, orelse }) => Ok(StmtKind::While(StmtWhile {
                test: Foldable::fold(test, folder)?,
                body: Foldable::fold(body, folder)?,
                orelse: Foldable::fold(orelse, folder)?,
            })),
            StmtKind::If(StmtIf { test, body, orelse }) => Ok(StmtKind::If(StmtIf {
                test: Foldable::fold(test, folder)?,
                body: Foldable::fold(body, folder)?,
                orelse: Foldable::fold(orelse, folder)?,
            })),
            StmtKind::With(StmtWith {
                items,
                body,
                type_comment,
            }) => Ok(StmtKind::With(StmtWith {
                items: Foldable::fold(items, folder)?,
                body: Foldable::fold(body, folder)?,
                type_comment: Foldable::fold(type_comment, folder)?,
            })),
            StmtKind::AsyncWith(StmtAsyncWith {
                items,
                body,
                type_comment,
            }) => Ok(StmtKind::AsyncWith(StmtAsyncWith {
                items: Foldable::fold(items, folder)?,
                body: Foldable::fold(body, folder)?,
                type_comment: Foldable::fold(type_comment, folder)?,
            })),
            StmtKind::Match(StmtMatch { subject, cases }) => Ok(StmtKind::Match(StmtMatch {
                subject: Foldable::fold(subject, folder)?,
                cases: Foldable::fold(cases, folder)?,
            })),
            StmtKind::Raise(StmtRaise { exc, cause }) => Ok(StmtKind::Raise(StmtRaise {
                exc: Foldable::fold(exc, folder)?,
                cause: Foldable::fold(cause, folder)?,
            })),
            StmtKind::Try(StmtTry {
                body,
                handlers,
                orelse,
                finalbody,
            }) => Ok(StmtKind::Try(StmtTry {
                body: Foldable::fold(body, folder)?,
                handlers: Foldable::fold(handlers, folder)?,
                orelse: Foldable::fold(orelse, folder)?,
                finalbody: Foldable::fold(finalbody, folder)?,
            })),
            StmtKind::TryStar(StmtTryStar {
                body,
                handlers,
                orelse,
                finalbody,
            }) => Ok(StmtKind::TryStar(StmtTryStar {
                body: Foldable::fold(body, folder)?,
                handlers: Foldable::fold(handlers, folder)?,
                orelse: Foldable::fold(orelse, folder)?,
                finalbody: Foldable::fold(finalbody, folder)?,
            })),
            StmtKind::Assert(StmtAssert { test, msg }) => Ok(StmtKind::Assert(StmtAssert {
                test: Foldable::fold(test, folder)?,
                msg: Foldable::fold(msg, folder)?,
            })),
            StmtKind::Import(StmtImport { names }) => Ok(StmtKind::Import(StmtImport {
                names: Foldable::fold(names, folder)?,
            })),
            StmtKind::ImportFrom(StmtImportFrom {
                module,
                names,
                level,
            }) => Ok(StmtKind::ImportFrom(StmtImportFrom {
                module: Foldable::fold(module, folder)?,
                names: Foldable::fold(names, folder)?,
                level: Foldable::fold(level, folder)?,
            })),
            StmtKind::Global(StmtGlobal { names }) => Ok(StmtKind::Global(StmtGlobal {
                names: Foldable::fold(names, folder)?,
            })),
            StmtKind::Nonlocal(StmtNonlocal { names }) => Ok(StmtKind::Nonlocal(StmtNonlocal {
                names: Foldable::fold(names, folder)?,
            })),
            StmtKind::Expr(StmtExpr { value }) => Ok(StmtKind::Expr(StmtExpr {
                value: Foldable::fold(value, folder)?,
            })),
            StmtKind::Pass {} => Ok(StmtKind::Pass {}),
            StmtKind::Break {} => Ok(StmtKind::Break {}),
            StmtKind::Continue {} => Ok(StmtKind::Continue {}),
        })
    }
    impl<T, U> Foldable<T, U> for Expr<T> {
        type Mapped = Expr<U>;
        fn fold<F: Fold<T, TargetU = U> + ?Sized>(
            self,
            folder: &mut F,
        ) -> Result<Self::Mapped, F::Error> {
            folder.fold_expr(self)
        }
    }
    pub fn fold_expr<U, F: Fold<U> + ?Sized>(
        #[allow(unused)] folder: &mut F,
        node: Expr<U>,
    ) -> Result<Expr<F::TargetU>, F::Error> {
        fold_located(folder, node, |folder, node| match node {
            ExprKind::BoolOp(ExprBoolOp { op, values }) => Ok(ExprKind::BoolOp(ExprBoolOp {
                op: Foldable::fold(op, folder)?,
                values: Foldable::fold(values, folder)?,
            })),
            ExprKind::NamedExpr(ExprNamedExpr { target, value }) => {
                Ok(ExprKind::NamedExpr(ExprNamedExpr {
                    target: Foldable::fold(target, folder)?,
                    value: Foldable::fold(value, folder)?,
                }))
            }
            ExprKind::BinOp(ExprBinOp { left, op, right }) => Ok(ExprKind::BinOp(ExprBinOp {
                left: Foldable::fold(left, folder)?,
                op: Foldable::fold(op, folder)?,
                right: Foldable::fold(right, folder)?,
            })),
            ExprKind::UnaryOp(ExprUnaryOp { op, operand }) => Ok(ExprKind::UnaryOp(ExprUnaryOp {
                op: Foldable::fold(op, folder)?,
                operand: Foldable::fold(operand, folder)?,
            })),
            ExprKind::Lambda(ExprLambda { args, body }) => Ok(ExprKind::Lambda(ExprLambda {
                args: Foldable::fold(args, folder)?,
                body: Foldable::fold(body, folder)?,
            })),
            ExprKind::IfExp(ExprIfExp { test, body, orelse }) => Ok(ExprKind::IfExp(ExprIfExp {
                test: Foldable::fold(test, folder)?,
                body: Foldable::fold(body, folder)?,
                orelse: Foldable::fold(orelse, folder)?,
            })),
            ExprKind::Dict(ExprDict { keys, values }) => Ok(ExprKind::Dict(ExprDict {
                keys: Foldable::fold(keys, folder)?,
                values: Foldable::fold(values, folder)?,
            })),
            ExprKind::Set(ExprSet { elts }) => Ok(ExprKind::Set(ExprSet {
                elts: Foldable::fold(elts, folder)?,
            })),
            ExprKind::ListComp(ExprListComp { elt, generators }) => {
                Ok(ExprKind::ListComp(ExprListComp {
                    elt: Foldable::fold(elt, folder)?,
                    generators: Foldable::fold(generators, folder)?,
                }))
            }
            ExprKind::SetComp(ExprSetComp { elt, generators }) => {
                Ok(ExprKind::SetComp(ExprSetComp {
                    elt: Foldable::fold(elt, folder)?,
                    generators: Foldable::fold(generators, folder)?,
                }))
            }
            ExprKind::DictComp(ExprDictComp {
                key,
                value,
                generators,
            }) => Ok(ExprKind::DictComp(ExprDictComp {
                key: Foldable::fold(key, folder)?,
                value: Foldable::fold(value, folder)?,
                generators: Foldable::fold(generators, folder)?,
            })),
            ExprKind::GeneratorExp(ExprGeneratorExp { elt, generators }) => {
                Ok(ExprKind::GeneratorExp(ExprGeneratorExp {
                    elt: Foldable::fold(elt, folder)?,
                    generators: Foldable::fold(generators, folder)?,
                }))
            }
            ExprKind::Await(ExprAwait { value }) => Ok(ExprKind::Await(ExprAwait {
                value: Foldable::fold(value, folder)?,
            })),
            ExprKind::Yield(ExprYield { value }) => Ok(ExprKind::Yield(ExprYield {
                value: Foldable::fold(value, folder)?,
            })),
            ExprKind::YieldFrom(ExprYieldFrom { value }) => {
                Ok(ExprKind::YieldFrom(ExprYieldFrom {
                    value: Foldable::fold(value, folder)?,
                }))
            }
            ExprKind::Compare(ExprCompare {
                left,
                ops,
                comparators,
            }) => Ok(ExprKind::Compare(ExprCompare {
                left: Foldable::fold(left, folder)?,
                ops: Foldable::fold(ops, folder)?,
                comparators: Foldable::fold(comparators, folder)?,
            })),
            ExprKind::Call(ExprCall {
                func,
                args,
                keywords,
            }) => Ok(ExprKind::Call(ExprCall {
                func: Foldable::fold(func, folder)?,
                args: Foldable::fold(args, folder)?,
                keywords: Foldable::fold(keywords, folder)?,
            })),
            ExprKind::FormattedValue(ExprFormattedValue {
                value,
                conversion,
                format_spec,
            }) => Ok(ExprKind::FormattedValue(ExprFormattedValue {
                value: Foldable::fold(value, folder)?,
                conversion: Foldable::fold(conversion, folder)?,
                format_spec: Foldable::fold(format_spec, folder)?,
            })),
            ExprKind::JoinedStr(ExprJoinedStr { values }) => {
                Ok(ExprKind::JoinedStr(ExprJoinedStr {
                    values: Foldable::fold(values, folder)?,
                }))
            }
            ExprKind::Constant(ExprConstant { value, kind }) => {
                Ok(ExprKind::Constant(ExprConstant {
                    value: Foldable::fold(value, folder)?,
                    kind: Foldable::fold(kind, folder)?,
                }))
            }
            ExprKind::Attribute(ExprAttribute { value, attr, ctx }) => {
                Ok(ExprKind::Attribute(ExprAttribute {
                    value: Foldable::fold(value, folder)?,
                    attr: Foldable::fold(attr, folder)?,
                    ctx: Foldable::fold(ctx, folder)?,
                }))
            }
            ExprKind::Subscript(ExprSubscript { value, slice, ctx }) => {
                Ok(ExprKind::Subscript(ExprSubscript {
                    value: Foldable::fold(value, folder)?,
                    slice: Foldable::fold(slice, folder)?,
                    ctx: Foldable::fold(ctx, folder)?,
                }))
            }
            ExprKind::Starred(ExprStarred { value, ctx }) => Ok(ExprKind::Starred(ExprStarred {
                value: Foldable::fold(value, folder)?,
                ctx: Foldable::fold(ctx, folder)?,
            })),
            ExprKind::Name(ExprName { id, ctx }) => Ok(ExprKind::Name(ExprName {
                id: Foldable::fold(id, folder)?,
                ctx: Foldable::fold(ctx, folder)?,
            })),
            ExprKind::List(ExprList { elts, ctx }) => Ok(ExprKind::List(ExprList {
                elts: Foldable::fold(elts, folder)?,
                ctx: Foldable::fold(ctx, folder)?,
            })),
            ExprKind::Tuple(ExprTuple { elts, ctx }) => Ok(ExprKind::Tuple(ExprTuple {
                elts: Foldable::fold(elts, folder)?,
                ctx: Foldable::fold(ctx, folder)?,
            })),
            ExprKind::Slice(ExprSlice { lower, upper, step }) => Ok(ExprKind::Slice(ExprSlice {
                lower: Foldable::fold(lower, folder)?,
                upper: Foldable::fold(upper, folder)?,
                step: Foldable::fold(step, folder)?,
            })),
        })
    }
    impl<T, U> Foldable<T, U> for ExprContext {
        type Mapped = ExprContext;
        fn fold<F: Fold<T, TargetU = U> + ?Sized>(
            self,
            folder: &mut F,
        ) -> Result<Self::Mapped, F::Error> {
            folder.fold_expr_context(self)
        }
    }
    pub fn fold_expr_context<U, F: Fold<U> + ?Sized>(
        #[allow(unused)] folder: &mut F,
        node: ExprContext,
    ) -> Result<ExprContext, F::Error> {
        match node {
            ExprContext::Load {} => Ok(ExprContext::Load {}),
            ExprContext::Store {} => Ok(ExprContext::Store {}),
            ExprContext::Del {} => Ok(ExprContext::Del {}),
        }
    }
    impl<T, U> Foldable<T, U> for Boolop {
        type Mapped = Boolop;
        fn fold<F: Fold<T, TargetU = U> + ?Sized>(
            self,
            folder: &mut F,
        ) -> Result<Self::Mapped, F::Error> {
            folder.fold_boolop(self)
        }
    }
    pub fn fold_boolop<U, F: Fold<U> + ?Sized>(
        #[allow(unused)] folder: &mut F,
        node: Boolop,
    ) -> Result<Boolop, F::Error> {
        match node {
            Boolop::And {} => Ok(Boolop::And {}),
            Boolop::Or {} => Ok(Boolop::Or {}),
        }
    }
    impl<T, U> Foldable<T, U> for Operator {
        type Mapped = Operator;
        fn fold<F: Fold<T, TargetU = U> + ?Sized>(
            self,
            folder: &mut F,
        ) -> Result<Self::Mapped, F::Error> {
            folder.fold_operator(self)
        }
    }
    pub fn fold_operator<U, F: Fold<U> + ?Sized>(
        #[allow(unused)] folder: &mut F,
        node: Operator,
    ) -> Result<Operator, F::Error> {
        match node {
            Operator::Add {} => Ok(Operator::Add {}),
            Operator::Sub {} => Ok(Operator::Sub {}),
            Operator::Mult {} => Ok(Operator::Mult {}),
            Operator::MatMult {} => Ok(Operator::MatMult {}),
            Operator::Div {} => Ok(Operator::Div {}),
            Operator::Mod {} => Ok(Operator::Mod {}),
            Operator::Pow {} => Ok(Operator::Pow {}),
            Operator::LShift {} => Ok(Operator::LShift {}),
            Operator::RShift {} => Ok(Operator::RShift {}),
            Operator::BitOr {} => Ok(Operator::BitOr {}),
            Operator::BitXor {} => Ok(Operator::BitXor {}),
            Operator::BitAnd {} => Ok(Operator::BitAnd {}),
            Operator::FloorDiv {} => Ok(Operator::FloorDiv {}),
        }
    }
    impl<T, U> Foldable<T, U> for Unaryop {
        type Mapped = Unaryop;
        fn fold<F: Fold<T, TargetU = U> + ?Sized>(
            self,
            folder: &mut F,
        ) -> Result<Self::Mapped, F::Error> {
            folder.fold_unaryop(self)
        }
    }
    pub fn fold_unaryop<U, F: Fold<U> + ?Sized>(
        #[allow(unused)] folder: &mut F,
        node: Unaryop,
    ) -> Result<Unaryop, F::Error> {
        match node {
            Unaryop::Invert {} => Ok(Unaryop::Invert {}),
            Unaryop::Not {} => Ok(Unaryop::Not {}),
            Unaryop::UAdd {} => Ok(Unaryop::UAdd {}),
            Unaryop::USub {} => Ok(Unaryop::USub {}),
        }
    }
    impl<T, U> Foldable<T, U> for Cmpop {
        type Mapped = Cmpop;
        fn fold<F: Fold<T, TargetU = U> + ?Sized>(
            self,
            folder: &mut F,
        ) -> Result<Self::Mapped, F::Error> {
            folder.fold_cmpop(self)
        }
    }
    pub fn fold_cmpop<U, F: Fold<U> + ?Sized>(
        #[allow(unused)] folder: &mut F,
        node: Cmpop,
    ) -> Result<Cmpop, F::Error> {
        match node {
            Cmpop::Eq {} => Ok(Cmpop::Eq {}),
            Cmpop::NotEq {} => Ok(Cmpop::NotEq {}),
            Cmpop::Lt {} => Ok(Cmpop::Lt {}),
            Cmpop::LtE {} => Ok(Cmpop::LtE {}),
            Cmpop::Gt {} => Ok(Cmpop::Gt {}),
            Cmpop::GtE {} => Ok(Cmpop::GtE {}),
            Cmpop::Is {} => Ok(Cmpop::Is {}),
            Cmpop::IsNot {} => Ok(Cmpop::IsNot {}),
            Cmpop::In {} => Ok(Cmpop::In {}),
            Cmpop::NotIn {} => Ok(Cmpop::NotIn {}),
        }
    }
    impl<T, U> Foldable<T, U> for Comprehension<T> {
        type Mapped = Comprehension<U>;
        fn fold<F: Fold<T, TargetU = U> + ?Sized>(
            self,
            folder: &mut F,
        ) -> Result<Self::Mapped, F::Error> {
            folder.fold_comprehension(self)
        }
    }
    pub fn fold_comprehension<U, F: Fold<U> + ?Sized>(
        #[allow(unused)] folder: &mut F,
        node: Comprehension<U>,
    ) -> Result<Comprehension<F::TargetU>, F::Error> {
        let Comprehension {
            target,
            iter,
            ifs,
            is_async,
        } = node;
        Ok(Comprehension {
            target: Foldable::fold(target, folder)?,
            iter: Foldable::fold(iter, folder)?,
            ifs: Foldable::fold(ifs, folder)?,
            is_async: Foldable::fold(is_async, folder)?,
        })
    }
    impl<T, U> Foldable<T, U> for Excepthandler<T> {
        type Mapped = Excepthandler<U>;
        fn fold<F: Fold<T, TargetU = U> + ?Sized>(
            self,
            folder: &mut F,
        ) -> Result<Self::Mapped, F::Error> {
            folder.fold_excepthandler(self)
        }
    }
    pub fn fold_excepthandler<U, F: Fold<U> + ?Sized>(
        #[allow(unused)] folder: &mut F,
        node: Excepthandler<U>,
    ) -> Result<Excepthandler<F::TargetU>, F::Error> {
        fold_located(folder, node, |folder, node| match node {
            ExcepthandlerKind::ExceptHandler(ExcepthandlerExceptHandler { type_, name, body }) => {
                Ok(ExcepthandlerKind::ExceptHandler(
                    ExcepthandlerExceptHandler {
                        type_: Foldable::fold(type_, folder)?,
                        name: Foldable::fold(name, folder)?,
                        body: Foldable::fold(body, folder)?,
                    },
                ))
            }
        })
    }
    impl<T, U> Foldable<T, U> for Arguments<T> {
        type Mapped = Arguments<U>;
        fn fold<F: Fold<T, TargetU = U> + ?Sized>(
            self,
            folder: &mut F,
        ) -> Result<Self::Mapped, F::Error> {
            folder.fold_arguments(self)
        }
    }
    pub fn fold_arguments<U, F: Fold<U> + ?Sized>(
        #[allow(unused)] folder: &mut F,
        node: Arguments<U>,
    ) -> Result<Arguments<F::TargetU>, F::Error> {
        let Arguments {
            posonlyargs,
            args,
            vararg,
            kwonlyargs,
            kw_defaults,
            kwarg,
            defaults,
        } = node;
        Ok(Arguments {
            posonlyargs: Foldable::fold(posonlyargs, folder)?,
            args: Foldable::fold(args, folder)?,
            vararg: Foldable::fold(vararg, folder)?,
            kwonlyargs: Foldable::fold(kwonlyargs, folder)?,
            kw_defaults: Foldable::fold(kw_defaults, folder)?,
            kwarg: Foldable::fold(kwarg, folder)?,
            defaults: Foldable::fold(defaults, folder)?,
        })
    }
    impl<T, U> Foldable<T, U> for Arg<T> {
        type Mapped = Arg<U>;
        fn fold<F: Fold<T, TargetU = U> + ?Sized>(
            self,
            folder: &mut F,
        ) -> Result<Self::Mapped, F::Error> {
            folder.fold_arg(self)
        }
    }
    pub fn fold_arg<U, F: Fold<U> + ?Sized>(
        #[allow(unused)] folder: &mut F,
        node: Arg<U>,
    ) -> Result<Arg<F::TargetU>, F::Error> {
        fold_located(folder, node, |folder, node| {
            let ArgData {
                arg,
                annotation,
                type_comment,
            } = node;
            Ok(ArgData {
                arg: Foldable::fold(arg, folder)?,
                annotation: Foldable::fold(annotation, folder)?,
                type_comment: Foldable::fold(type_comment, folder)?,
            })
        })
    }
    impl<T, U> Foldable<T, U> for Keyword<T> {
        type Mapped = Keyword<U>;
        fn fold<F: Fold<T, TargetU = U> + ?Sized>(
            self,
            folder: &mut F,
        ) -> Result<Self::Mapped, F::Error> {
            folder.fold_keyword(self)
        }
    }
    pub fn fold_keyword<U, F: Fold<U> + ?Sized>(
        #[allow(unused)] folder: &mut F,
        node: Keyword<U>,
    ) -> Result<Keyword<F::TargetU>, F::Error> {
        fold_located(folder, node, |folder, node| {
            let KeywordData { arg, value } = node;
            Ok(KeywordData {
                arg: Foldable::fold(arg, folder)?,
                value: Foldable::fold(value, folder)?,
            })
        })
    }
    impl<T, U> Foldable<T, U> for Alias<T> {
        type Mapped = Alias<U>;
        fn fold<F: Fold<T, TargetU = U> + ?Sized>(
            self,
            folder: &mut F,
        ) -> Result<Self::Mapped, F::Error> {
            folder.fold_alias(self)
        }
    }
    pub fn fold_alias<U, F: Fold<U> + ?Sized>(
        #[allow(unused)] folder: &mut F,
        node: Alias<U>,
    ) -> Result<Alias<F::TargetU>, F::Error> {
        fold_located(folder, node, |folder, node| {
            let AliasData { name, asname } = node;
            Ok(AliasData {
                name: Foldable::fold(name, folder)?,
                asname: Foldable::fold(asname, folder)?,
            })
        })
    }
    impl<T, U> Foldable<T, U> for Withitem<T> {
        type Mapped = Withitem<U>;
        fn fold<F: Fold<T, TargetU = U> + ?Sized>(
            self,
            folder: &mut F,
        ) -> Result<Self::Mapped, F::Error> {
            folder.fold_withitem(self)
        }
    }
    pub fn fold_withitem<U, F: Fold<U> + ?Sized>(
        #[allow(unused)] folder: &mut F,
        node: Withitem<U>,
    ) -> Result<Withitem<F::TargetU>, F::Error> {
        let Withitem {
            context_expr,
            optional_vars,
        } = node;
        Ok(Withitem {
            context_expr: Foldable::fold(context_expr, folder)?,
            optional_vars: Foldable::fold(optional_vars, folder)?,
        })
    }
    impl<T, U> Foldable<T, U> for MatchCase<T> {
        type Mapped = MatchCase<U>;
        fn fold<F: Fold<T, TargetU = U> + ?Sized>(
            self,
            folder: &mut F,
        ) -> Result<Self::Mapped, F::Error> {
            folder.fold_match_case(self)
        }
    }
    pub fn fold_match_case<U, F: Fold<U> + ?Sized>(
        #[allow(unused)] folder: &mut F,
        node: MatchCase<U>,
    ) -> Result<MatchCase<F::TargetU>, F::Error> {
        let MatchCase {
            pattern,
            guard,
            body,
        } = node;
        Ok(MatchCase {
            pattern: Foldable::fold(pattern, folder)?,
            guard: Foldable::fold(guard, folder)?,
            body: Foldable::fold(body, folder)?,
        })
    }
    impl<T, U> Foldable<T, U> for Pattern<T> {
        type Mapped = Pattern<U>;
        fn fold<F: Fold<T, TargetU = U> + ?Sized>(
            self,
            folder: &mut F,
        ) -> Result<Self::Mapped, F::Error> {
            folder.fold_pattern(self)
        }
    }
    pub fn fold_pattern<U, F: Fold<U> + ?Sized>(
        #[allow(unused)] folder: &mut F,
        node: Pattern<U>,
    ) -> Result<Pattern<F::TargetU>, F::Error> {
        fold_located(folder, node, |folder, node| match node {
            PatternKind::MatchValue(PatternMatchValue { value }) => {
                Ok(PatternKind::MatchValue(PatternMatchValue {
                    value: Foldable::fold(value, folder)?,
                }))
            }
            PatternKind::MatchSingleton(PatternMatchSingleton { value }) => {
                Ok(PatternKind::MatchSingleton(PatternMatchSingleton {
                    value: Foldable::fold(value, folder)?,
                }))
            }
            PatternKind::MatchSequence(PatternMatchSequence { patterns }) => {
                Ok(PatternKind::MatchSequence(PatternMatchSequence {
                    patterns: Foldable::fold(patterns, folder)?,
                }))
            }
            PatternKind::MatchMapping(PatternMatchMapping {
                keys,
                patterns,
                rest,
            }) => Ok(PatternKind::MatchMapping(PatternMatchMapping {
                keys: Foldable::fold(keys, folder)?,
                patterns: Foldable::fold(patterns, folder)?,
                rest: Foldable::fold(rest, folder)?,
            })),
            PatternKind::MatchClass(PatternMatchClass {
                cls,
                patterns,
                kwd_attrs,
                kwd_patterns,
            }) => Ok(PatternKind::MatchClass(PatternMatchClass {
                cls: Foldable::fold(cls, folder)?,
                patterns: Foldable::fold(patterns, folder)?,
                kwd_attrs: Foldable::fold(kwd_attrs, folder)?,
                kwd_patterns: Foldable::fold(kwd_patterns, folder)?,
            })),
            PatternKind::MatchStar(PatternMatchStar { name }) => {
                Ok(PatternKind::MatchStar(PatternMatchStar {
                    name: Foldable::fold(name, folder)?,
                }))
            }
            PatternKind::MatchAs(PatternMatchAs { pattern, name }) => {
                Ok(PatternKind::MatchAs(PatternMatchAs {
                    pattern: Foldable::fold(pattern, folder)?,
                    name: Foldable::fold(name, folder)?,
                }))
            }
            PatternKind::MatchOr(PatternMatchOr { patterns }) => {
                Ok(PatternKind::MatchOr(PatternMatchOr {
                    patterns: Foldable::fold(patterns, folder)?,
                }))
            }
        })
    }
    impl<T, U> Foldable<T, U> for TypeIgnore {
        type Mapped = TypeIgnore;
        fn fold<F: Fold<T, TargetU = U> + ?Sized>(
            self,
            folder: &mut F,
        ) -> Result<Self::Mapped, F::Error> {
            folder.fold_type_ignore(self)
        }
    }
    pub fn fold_type_ignore<U, F: Fold<U> + ?Sized>(
        #[allow(unused)] folder: &mut F,
        node: TypeIgnore,
    ) -> Result<TypeIgnore, F::Error> {
        match node {
            TypeIgnore::TypeIgnore(TypeIgnoreTypeIgnore { lineno, tag }) => {
                Ok(TypeIgnore::TypeIgnore(TypeIgnoreTypeIgnore {
                    lineno: Foldable::fold(lineno, folder)?,
                    tag: Foldable::fold(tag, folder)?,
                }))
            }
        }
    }
}
